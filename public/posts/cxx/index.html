<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solving the Rust-C++ Integration Challenge: A Practical Guide | Digital Reservoirs</title><meta name=keywords content><meta name=description content="Problem Statement
I was recently working on a Tauri application and needed to add a new backend feature.  This feature had already been implemented in our C++ codebase. Rather than rewriting the functionality in Rust, I chose to link to the existing C++ code directly to Rust to save time and maintain consistency with existing applications.
Approaches
Don&rsquo;t Reinvent the Wheel
To begin, I reviewed our existing slate of Tauri apps.  There was one Tauri app which does call C++ code using the libc crate. This implementation meant that only C-native data types could be sent between C++ and Rust.  As my use case involves sending vectors and strings between the two languages, libc would not work for me."><meta name=author content="Dan Costello"><link rel=canonical href=http://localhost:1313/posts/cxx/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/cxx/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/cxx/"><meta property="og:site_name" content="Digital Reservoirs"><meta property="og:title" content="Solving the Rust-C++ Integration Challenge: A Practical Guide"><meta property="og:description" content="Problem Statement I was recently working on a Tauri application and needed to add a new backend feature. This feature had already been implemented in our C++ codebase. Rather than rewriting the functionality in Rust, I chose to link to the existing C++ code directly to Rust to save time and maintain consistency with existing applications.
Approaches Don’t Reinvent the Wheel To begin, I reviewed our existing slate of Tauri apps. There was one Tauri app which does call C++ code using the libc crate. This implementation meant that only C-native data types could be sent between C++ and Rust. As my use case involves sending vectors and strings between the two languages, libc would not work for me."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-28T11:40:03-04:00"><meta property="article:modified_time" content="2025-04-28T11:40:03-04:00"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Solving the Rust-C++ Integration Challenge: A Practical Guide"><meta name=twitter:description content="Problem Statement
I was recently working on a Tauri application and needed to add a new backend feature.  This feature had already been implemented in our C++ codebase. Rather than rewriting the functionality in Rust, I chose to link to the existing C++ code directly to Rust to save time and maintain consistency with existing applications.
Approaches
Don&rsquo;t Reinvent the Wheel
To begin, I reviewed our existing slate of Tauri apps.  There was one Tauri app which does call C++ code using the libc crate. This implementation meant that only C-native data types could be sent between C++ and Rust.  As my use case involves sending vectors and strings between the two languages, libc would not work for me."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Solving the Rust-C++ Integration Challenge: A Practical Guide","item":"http://localhost:1313/posts/cxx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solving the Rust-C++ Integration Challenge: A Practical Guide","name":"Solving the Rust-C\u002b\u002b Integration Challenge: A Practical Guide","description":"Problem Statement I was recently working on a Tauri application and needed to add a new backend feature. This feature had already been implemented in our C++ codebase. Rather than rewriting the functionality in Rust, I chose to link to the existing C++ code directly to Rust to save time and maintain consistency with existing applications.\nApproaches Don\u0026rsquo;t Reinvent the Wheel To begin, I reviewed our existing slate of Tauri apps. There was one Tauri app which does call C++ code using the libc crate. This implementation meant that only C-native data types could be sent between C++ and Rust. As my use case involves sending vectors and strings between the two languages, libc would not work for me.\n","keywords":[],"articleBody":"Problem Statement I was recently working on a Tauri application and needed to add a new backend feature. This feature had already been implemented in our C++ codebase. Rather than rewriting the functionality in Rust, I chose to link to the existing C++ code directly to Rust to save time and maintain consistency with existing applications.\nApproaches Don’t Reinvent the Wheel To begin, I reviewed our existing slate of Tauri apps. There was one Tauri app which does call C++ code using the libc crate. This implementation meant that only C-native data types could be sent between C++ and Rust. As my use case involves sending vectors and strings between the two languages, libc would not work for me.\nFinding cxx Googling around, I found the cxx crate which promised safe linking of C++ and Rust code, including support for vectors and strings. I started by mapping directly to the function in the C++ lib. This led to numerous of errors, and it wasn’t explicitly clear what I was doing wrong. I pounded the error messages through google, stack overflow, and Claude to try to find a quick fix, with no good results. Cxx seemed like the best bet, but I needed to step back a bit.\nStart with minimal reproduction When working with new libraries, I learn best by looking at others’ code and adapting it to my needs. Thankfully, the maintainers of CXX crate are nice enough to include a tutorial section. To confirm everything worked on my machine, I first downloaded the tutorial repo and ran the code to ensure my machine was set up correctly. Next, I deleted this downloaded repository and started over. This time, I read through the tutorial and coded along line by line, to better understand how the pieces fit together. It was great to be able to understand the workings of the Cxx crate. Once I’d completed the tutorial, I aimed to extend the tutorial to fit my use case - calling a function with two parameters - (1) a Vector of Strings, and (2) a string. I kept this extension super-simple to ensure I was calling functions correctly.\nProblem 1 - can’t push to a CxxVector from Rust In my ideal use case, I build a CxxVector/ in Rust and pass that as an argument to the C++ function. The problem I ran into is that Cxx doesn’t allow pushing new members to a CxxVector from Rust. My solution: Create a utility functions to push to a CxxString to CxxVector.\nvoid push_string(std::vector \u0026vec, const std::string \u0026str) { vec.push_back(std::move(str)); } Now I can call push_string from rust with the vector and string arguments:\nuse cxx::{CxxString, CxxVector, let_cxx_string}; use ffi::push_string; #[cxx::bridge] mod ffi { unsafe extern \"C++\" { include!(\"cxx-demo/include/helper.h\"); fn push_string(vec: Pin\u003c\u0026mut CxxVector\u003e, str: \u0026CxxString); } } fn main() { let mut vec = CxxVector::::new(); let_cxx_string!(hello = \"Hello\"); let_cxx_string!(world= \"World\"); push_string(vec.pin_mut(), \u0026hello); push_string(vec.pin_mut(), \u0026world); println!(\"Result is: {:?}\", vec); } A working version of this example is available here.\nProblem 2 - can’t return a CxxString from C++ to Rust by Value After solving the “vector push” issue, I encountered another challenge with returning strings from C++ to Rust. The cxx crate does not allow the C++ function to return a string to Rust by value - rather, it needs to send a reference/pointer (explanation here). Therefore, I can’t call the existing C++ function directly from Rust - I’ll need to create another C++ wrapper function that returns a pointer to the String.\nOne important note: as findPropertyKind is defined in the C++ libraries that I link to, I do not need to provide the function definition in my helper.cc function (where I have defined push_string and findPropertyKindFromAttrs wrapper function). However, I do need to provide a function signature in include/helper.h to define its inputs and outputs.\nstd::unique_ptr findPropertyKindFromAttrs( const std::vector \u0026attrs, const std::string \u0026kind) { std::string result = std::string(findPropertyKind(attrs, kind)); return std::make_unique(result); } Linking to existing code So now I have my wrapper functions and everything works in my extended version of the cxx tutorial. It is time to take these learnings over to my actual project. I replicated the helper functions for pushing to a CxxVector in my feature branch and verified they ran. Next up, I tested the wrapper function. This did not work straight away, and failed with the ominous error that Rust cannot catch foreign exceptions. It took me a while to figure it out, but eventually realized that the C++ code was expecting an environment variable to be set that I didn’t have in my testing environment. Once this variable was set, the code worked!\nBuilding To allow the rust compiler to link to the compiled C++ libraries, I added a build.rs to my Rust project’s base folder. First, need to tell the compiler where to look for libraries:\nprintln!(\"cargo:rustc-link-search=/path/to/libs\"); Then link to specific library names:\nprintln!(\"cargo:rustc-link-lib=static=lib1\"); println!(\"cargo:rustc-link-lib=static=lib2\"); println!(\"cargo:rustc-link-lib=lib3\"); As we compile our software for both Linux and Windows, I needed to use some if/else blocks (i.e if std::env::consts::OS == \"linux\") to specify different link search paths for each operating system.\nRoom for Improvement Providing C++ signatures in header file In an earlier implementation, I used include! macro in main.rs to include the header file that contains the signature for findPropertyKind. This appears to be necessary so that the compiler can confirm I am calling it correctly from my wrapper function. However, this led to issues with version control and building on other machines as I had to allow for users having the C++ repository in different locations. I was able to resolve this by removing the include! macro usage for linking to the original C++ source code, and providing a copy of the FindPropertyKind signature in helper.h. Although this involved copy and paste, it cleaned up build pipeline for me.\nDo I actually need push_string function defined? It seems that it should be unnecessary for me to create the push_string helper function. If I were extending this work to work with vectors of other types, I’d have to create other helper functions to push various data types to CxxVector. I shared the code sandbox link above with cxx maintainers to ask if I was using best practices, and will follow up here.\nSharing with others I am writing this up for a couple of reasons. The first is selfish, in that it will allow me to come back and reference my thought process when linking other pieces of C++ code to Rust (and vice versa). The second is a bit more community oriented, in that there aren’t many detailed examples of linking Rust to C++ code. The cxx tutorial was a great resource, and my work extends that a bit for a particular use case.\nConclusions Being able to link Rust code to existing C++ code is a huge boon to productivity for my company (and many others, I’m guessing). Such links allow us to leverage existing code functionality without rewriting in other languages and ensuring behavior matches when called from various modules. Big thanks to the maintainers of cxx crate, especially its creator dtolnay!\n","wordCount":"1179","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-04-28T11:40:03-04:00","dateModified":"2025-04-28T11:40:03-04:00","author":{"@type":"Person","name":"Dan Costello"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/cxx/"},"publisher":{"@type":"Organization","name":"Digital Reservoirs","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Digital Reservoirs (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Digital Reservoirs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Solving the Rust-C++ Integration Challenge: A Practical Guide
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2025-04-28 11:40:03 -0400 EDT'>April 28, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1179 words&nbsp;·&nbsp;Dan Costello</div></header><div class=post-content><h2 id=problem-statement>Problem Statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h2><p>I was recently working on a Tauri application and needed to add a new backend feature. This feature had already been implemented in our C++ codebase. Rather than rewriting the functionality in Rust, I chose to link to the existing C++ code directly to Rust to save time and maintain consistency with existing applications.</p><h2 id=approaches>Approaches<a hidden class=anchor aria-hidden=true href=#approaches>#</a></h2><h3 id=dont-reinvent-the-wheel>Don&rsquo;t Reinvent the Wheel<a hidden class=anchor aria-hidden=true href=#dont-reinvent-the-wheel>#</a></h3><p>To begin, I reviewed our existing slate of Tauri apps. There was one Tauri app which does call C++ code using the <code>libc</code> crate. This implementation meant that only C-native data types could be sent between C++ and Rust. As my use case involves sending vectors and strings between the two languages, <code>libc</code> would not work for me.</p><h3 id=finding-cxx>Finding cxx<a hidden class=anchor aria-hidden=true href=#finding-cxx>#</a></h3><p>Googling around, I found the <code>cxx</code> crate which promised safe linking of C++ and Rust code, including support for vectors and strings. I started by mapping directly to the function in the C++ lib. This led to numerous of errors, and it wasn&rsquo;t explicitly clear what I was doing wrong. I pounded the error messages through google, stack overflow, and Claude to try to find a quick fix, with no good results. Cxx seemed like the best bet, but I needed to step back a bit.</p><h3 id=start-with-minimal-reproduction>Start with minimal reproduction<a hidden class=anchor aria-hidden=true href=#start-with-minimal-reproduction>#</a></h3><p>When working with new libraries, I learn best by looking at others&rsquo; code and adapting it to my needs. Thankfully, the maintainers of CXX crate are nice enough to include a tutorial section. To confirm everything worked on my machine, I first downloaded the tutorial repo and ran the code to ensure my machine was set up correctly. Next, I deleted this downloaded repository and started over. This time, I read through the tutorial and coded along line by line, to better understand how the pieces fit together. It was great to be able to understand the workings of the Cxx crate. Once I&rsquo;d completed the tutorial, I aimed to extend the tutorial to fit my use case - calling a function with two parameters - (1) a Vector of Strings, and (2) a string. I kept this extension super-simple to ensure I was calling functions correctly.</p><h4 id=problem-1---cant-push-to-a-cxxvector-from-rust>Problem 1 - can&rsquo;t push to a CxxVector from Rust<a hidden class=anchor aria-hidden=true href=#problem-1---cant-push-to-a-cxxvector-from-rust>#</a></h4><p>In my ideal use case, I build a CxxVector/ in Rust and pass that as an argument to the C++ function. The problem I ran into is that Cxx doesn&rsquo;t allow pushing new members to a CxxVector from Rust. My solution: Create a utility functions to push to a CxxString to CxxVector.</p><pre tabindex=0><code>void push_string(std::vector&lt;std::string&gt; &amp;vec, const std::string &amp;str)
{
    vec.push_back(std::move(str));
}
</code></pre><p>Now I can call <code>push_string</code> from rust with the vector and string arguments:</p><pre tabindex=0><code>use cxx::{CxxString, CxxVector, let_cxx_string};
use ffi::push_string;

#[cxx::bridge]
mod ffi {
    unsafe extern &#34;C++&#34; {
        include!(&#34;cxx-demo/include/helper.h&#34;);
        fn push_string(vec: Pin&lt;&amp;mut CxxVector&lt;CxxString&gt;&gt;, str: &amp;CxxString);
    }
}

fn main() {
    let mut vec = CxxVector::&lt;CxxString&gt;::new();
    let_cxx_string!(hello = &#34;Hello&#34;);
    let_cxx_string!(world= &#34;World&#34;);
    push_string(vec.pin_mut(), &amp;hello);
    push_string(vec.pin_mut(), &amp;world);

    println!(&#34;Result is: {:?}&#34;, vec);
}
</code></pre><p>A working version of this example is available <a href=https://codesandbox.io/p/devbox/unruffled-browser-h6qmhh>here</a>.</p><h4 id=problem-2---cant-return-a-cxxstring-from-c-to-rust-by-value>Problem 2 - can&rsquo;t return a CxxString from C++ to Rust by Value<a hidden class=anchor aria-hidden=true href=#problem-2---cant-return-a-cxxstring-from-c-to-rust-by-value>#</a></h4><p>After solving the &ldquo;vector push&rdquo; issue, I encountered another challenge with returning strings from C++ to Rust. The <code>cxx</code> crate does not allow the C++ function to return a string to Rust by value - rather, it needs to send a reference/pointer (explanation <a href="https://news.ycombinator.com/item?id=26565444#:~:text=std%3A%3Astring%20and%20std%3A%3Avector%20are%20not%20things%20that%20can%20exist%20by%20value%20in%20Rust">here</a>). Therefore, I can&rsquo;t call the existing C++ function directly from Rust - I&rsquo;ll need to create another C++ wrapper function that returns a pointer to the String.</p><p>One important note: as findPropertyKind is defined in the C++ libraries that I link to, I do not need to provide the function definition in my helper.cc function (where I have defined <code>push_string</code> and <code>findPropertyKindFromAttrs</code> wrapper function). However, I do need to provide a function signature in <code>include/helper.h</code> to define its inputs and outputs.</p><pre tabindex=0><code>std::unique_ptr&lt;std::string&gt; findPropertyKindFromAttrs(
    const std::vector&lt;std::string&gt; &amp;attrs,
    const std::string &amp;kind)
{

    std::string result = std::string(findPropertyKind(attrs, kind));
    return std::make_unique&lt;std::string&gt;(result);
}
</code></pre><h3 id=linking-to-existing-code>Linking to existing code<a hidden class=anchor aria-hidden=true href=#linking-to-existing-code>#</a></h3><p>So now I have my wrapper functions and everything works in my extended version of the <code>cxx</code> tutorial. It is time to take these learnings over to my actual project. I replicated the helper functions for pushing to a CxxVector in my feature branch and verified they ran. Next up, I tested the wrapper function. This did not work straight away, and failed with the ominous error that <code>Rust cannot catch foreign exceptions</code>. It took me a while to figure it out, but eventually realized that the C++ code was expecting an environment variable to be set that I didn&rsquo;t have in my testing environment. Once this variable was set, the code worked!</p><h2 id=building>Building<a hidden class=anchor aria-hidden=true href=#building>#</a></h2><p>To allow the rust compiler to link to the compiled C++ libraries, I added a build.rs to my Rust project&rsquo;s base folder. First, need to tell the compiler where to look for libraries:</p><pre tabindex=0><code>println!(&#34;cargo:rustc-link-search=/path/to/libs&#34;);
</code></pre><p>Then link to specific library names:</p><pre tabindex=0><code>println!(&#34;cargo:rustc-link-lib=static=lib1&#34;);
println!(&#34;cargo:rustc-link-lib=static=lib2&#34;);
println!(&#34;cargo:rustc-link-lib=lib3&#34;);
</code></pre><p>As we compile our software for both Linux and Windows, I needed to use some if/else blocks (i.e <code>if std::env::consts::OS == "linux"</code>) to specify different link search paths for each operating system.</p><h2 id=room-for-improvement>Room for Improvement<a hidden class=anchor aria-hidden=true href=#room-for-improvement>#</a></h2><h3 id=providing-c-signatures-in-header-file>Providing C++ signatures in header file<a hidden class=anchor aria-hidden=true href=#providing-c-signatures-in-header-file>#</a></h3><p>In an earlier implementation, I used include! macro in main.rs to include the header file that contains the signature for findPropertyKind. This appears to be necessary so that the compiler can confirm I am calling it correctly from my wrapper function. However, this led to issues with version control and building on other machines as I had to allow for users having the C++ repository in different locations. I was able to resolve this by removing the include! macro usage for linking to the original C++ source code, and providing a copy of the FindPropertyKind signature in helper.h. Although this involved copy and paste, it cleaned up build pipeline for me.</p><h3 id=do-i-actually-need-push_string-function-defined>Do I actually need push_string function defined?<a hidden class=anchor aria-hidden=true href=#do-i-actually-need-push_string-function-defined>#</a></h3><p>It seems that it should be unnecessary for me to create the push_string helper function. If I were extending this work to work with vectors of other types, I&rsquo;d have to create other helper functions to push various data types to CxxVector. I shared the code sandbox link above with cxx maintainers to ask if I was using best practices, and will follow up here.</p><h3 id=sharing-with-others>Sharing with others<a hidden class=anchor aria-hidden=true href=#sharing-with-others>#</a></h3><p>I am writing this up for a couple of reasons. The first is selfish, in that it will allow me to come back and reference my thought process when linking other pieces of C++ code to Rust (and vice versa). The second is a bit more community oriented, in that there aren&rsquo;t many detailed examples of linking Rust to C++ code. The cxx tutorial was a great resource, and my work extends that a bit for a particular use case.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Being able to link Rust code to existing C++ code is a huge boon to productivity for my company (and many others, I&rsquo;m guessing). Such links allow us to leverage existing code functionality without rewriting in other languages and ensuring behavior matches when called from various modules. Big thanks to the maintainers of <a href=https://github.com/dtolnay/cxx>cxx crate</a>, especially its creator <a href=https://github.com/dtolnay>dtolnay</a>!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/tauri-and-redhat/><span class=title>« Prev</span><br><span>Why Tauri v2 and Red Hat don’t mix…yet</span>
</a><a class=next href=http://localhost:1313/posts/my-first-post/><span class=title>Next »</span><br><span>My First Post</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Digital Reservoirs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>